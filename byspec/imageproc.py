import multiprocessing as mp
import numpy as np
import scipy.signal

def _combine_clipdata(data, mask=None, mode='mean', upper_clip=None,
                      lower_clip=None, maxiter=10, maskmode=None):
    """Combine a clip data.

    Args:
        data (:class:`numpy.ndarray`): Datacube of input images.
        mask (:class:`numpy.ndarray`): Initial mask with the same shape with
            **data**.
        mode (str): Combine mode. Either "mean" or "sum".
        upper_clip (float): Upper threshold of the sigma-clipping. Default is
            *None*.
        lower_clip (float): Lower threshold of the sigma-clipping. Default is
            *None*.
        maxiter (int): Maximum number of iterations.
        maskmode (str): Mode of initial mask. Optional values are "min" and
            "max".
        nprocessors (int): Number of processors.

    Returns:
        :class:`numpy.ndarray`: Combined image array.

    See Also:
        :func:`combine_images`
    """

    nz, ny, nx = data.shape
    # generate a mask containing the positions of maximum pixel
    # along the first dimension

    if maskmode is None:
        mask2 = np.zeros_like(data, dtype=bool)
    elif maskmode == 'max':
        mask2 = (np.mgrid[0:nz, 0:ny, 0:nx][0] == data.argmax(axis=0))
    elif maskmode == 'min':
        mask2 = (np.mgrid[0:nz, 0:ny, 0:nx][0] == data.argmin(axis=0))
    else:
        print('Unknown maskmode:', maskmode)
        raise ValueError

    mask = np.logical_or(mask, mask2)

    # iteration begins
    for niter in range(maxiter):
        mdata = np.ma.masked_array(data, mask=mask)
        mean = mdata.mean(axis=0, dtype=np.float64).data
        std = mdata.std(axis=0, dtype=np.float64).data
        new_mask = np.ones_like(mask, dtype=bool)
        for i in np.arange(nz):
            chunk = data[i, :, :]

            # parse upper clipping
            if upper_clip is None:
                # mask1 = [False....]
                mask1 = np.zeros_like(chunk, dtype=bool)
            else:
                mask1 = chunk > mean + abs(upper_clip) * std

            # parse lower clipping
            if lower_clip is None:
                # mask2 = [False....]
                mask2 = np.zeros_like(chunk, dtype=bool)
            else:
                mask2 = chunk < mean - abs(lower_clip) * std

            new_mask[i, :, :] = np.logical_or(mask1, mask2)

        if new_mask.sum() == mask.sum():
            break
        mask = new_mask

    mdata = np.ma.masked_array(data, mask=mask)

    if mode == 'mean':
        return mdata.mean(axis=0).data
    elif mode == 'sum':
        return mdata.mean(axis=0).data * nz
    elif mode == 'median':
        return np.median(mdata, axis=0).data
    else:
        return None

def combine_images(data, mask=None, mode='mean', upper_clip=None,
                   lower_clip=None, maxiter=10, maskmode=None, ncores=1):
    """Combine multiple FITS images.

    Args:
        data (:class:`numpy.ndarray`): Datacube of input images.
        mask (:class:`numpy.ndarray`): Initial mask with the same shape with
            **data**.
        mode (str): Combine mode. Either "mean" or "sum".
        upper_clip (float): Upper threshold of the sigma-clipping. Default is
            *None*.
        lower_clip (float): Lower threshold of the sigma-clipping. Default is
            *None*.
        maxiter (int): Maximum number of iterations.
        maskmode (str): Mode of initial mask. Optional values are "min" and
            "max".
        ncores (int): Number of cores.

    Returns:
        :class:`numpy.ndarray`: Combined image array.

    Raises:
        TypeError: Dimension of **data** not equal to 3.
        ValueError: Unknown **mode** or **maskmode**.

    See Also:
        :func:`_combine_clipdata`

    This function can be used to calculate the median, mean, or sum of a list of
    FITS images.
    **maskmode** is the mode of initial mask. If "min" or "max" is given, the
    initial mask will be generated by blocking the minimum or maximum value of
    each pixel of the input images.
    If both **mask** and **maskmode** is given, the initial mask will be the
    logical *AND* of the input **mask** and the mask array generated by
    **maskmode**.

    """

    if data.ndim != 3:
        raise ValueError

    # if anyone of upper_clip and lower_clip is not None, then clip is True
    clip = (upper_clip is not None) or (lower_clip is not None)

    nimage, nY, nX = data.shape

    if clip:
        # perform sigma-clipping algorithm
        # initialize the final result array
        final_array = np.zeros((nY, nX))

        def get_fraction(N):
            if N > 8000:
                for i in [32, 16, 8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 4000:
                for i in [16, 8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 2000:
                for i in [8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 1000:
                for i in [4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 500:
                for i in [2, 1]:
                    if N % i == 0: return N // i
            else:
                return N

        # split the image into small segmentations
        dy = get_fraction(nY)
        dx = get_fraction(nX)

        pool = mp.Pool(ncores)
        async_result_lst = {}

        if mask is None:
            mask = np.zeros_like(data, dtype=bool)

        # segmentation loop starts here
        for y1 in np.arange(0, nY, dy):
            y2 = y1 + dy
            for x1 in np.arange(0, nX, dx):
                x2 = x1 + dx

                clipdata = data[:, y1:y2, x1:x2]
                clipmask = mask[:, y1:y2, x1:x2]
                result = pool.apply_async(_combine_clipdata,
                        args=(clipdata, clipmask, mode, upper_clip, lower_clip,
                              maxiter, maskmode))
                async_result_lst[(x1, x2, y1, y2)] = result
        # segmentation loop ends here

        pool.close()
        pool.join()

        for key, result in async_result_lst.items():
            x1, x2, y1, y2 = key
            final_array[y1:y2, x1:x2] = result.get()

        return final_array
    else:
        if mode == 'mean':
            return data.mean(axis=0)
        elif mode == 'sum':
            return data.sum(axis=0)
        elif mode == 'median':
            return np.median(data, axis=0)
        else:
            raise ValueError
            return None

def savgol_filter_2d(z, window_length, order, mode='reflect', cval=None,
        derivative=None):
    """Savitzky-Golay 2D filter, with different window size and order along *x*
    and *y* directions.

    Args:
        z (:class:`numpy.ndarray`): Input 2-d array.
        window_length (int, tuple, or list): Window size in pixel.
        order (int, tuple, or list): Degree of polynomial.
        mode (str): Edge Mode.
        derivative (str): *None*, *col*, *row*, or *both*.

    Returns:
        :class:`numpy.ndarray` or tuple: Output 2-d array, or a tuple containing
            derivative arries along *x*- and *y*-axes, respetively, if
            derivative = "both".
        
    """
    if isinstance(window_length, int):
        ywin, xwin = window_length, window_length
    elif isinstance(window_length, (tuple, list)):
        ywin, xwin = window_length[0], window_length[1]
    else:
        raise ValueError
    if xwin%2==0 or ywin%2==0:
        raise ValueError('window_length must be odd')

    if isinstance(order, int):
        yorder, xorder = order, order
    elif isinstance(order, (tuple, list)):
        yorder, xorder = order[0], order[1]
    else:
        raise ValueError

    # half of the window size
    yhalf = ywin//2
    xhalf = xwin//2

    # exponents of the polynomial. 
    # p(x,y) = a0 + a1*x + a2*y + a3*x^2 + a4*y^2 + a5*x*y + ...
    # this line gives a list of two item tuple. Each tuple contains
    # the exponents of the k-th term. First element of tuple is for x
    # second element for y.
    # Ex. exps = [(0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ...]
    maxorder = max(xorder, yorder)
    exps = [(k-n, n) for k in range(max(xorder, yorder)+1) for n in range(k+1)
            if k-n <= xorder and n <= yorder]

    # coordinates of points
    xind = np.arange(-xhalf, xhalf+1, dtype=np.float64)
    yind = np.arange(-yhalf, yhalf+1, dtype=np.float64)
    dx = np.repeat(xind, ywin)
    dy = np.tile(yind, [xwin, 1]).reshape(xwin*ywin,)

    # build matrix of system of equation
    A = np.empty(((xwin*ywin), len(exps)))
    for i, exp in enumerate(exps):
        A[:, i] = (dx**exp[0])*(dy**exp[1])

    Z = expand_2darray(z, (yhalf, xhalf), mode=mode, cval=cval)

    # solve system and convolve
    if derivative is None:
        m = np.linalg.pinv(A)[0].reshape((ywin, xwin))
        return scipy.signal.fftconvolve(Z, m, mode='valid')
    elif derivative == 'col':
        c = np.linalg.pinv(A)[1].reshape((ywin, xwin))
        return scipy.signal.fftconvolve(Z, -c, mode='valid')
    elif derivative == 'row':
        r = np.linalg.pinv(A)[2].rehsape((ywin, xwin))
        return scipy.signal.fftconvolve(Z, -r, mode='valid')
    elif derivative == 'both':
        c = np.linalg.pinv(A)[1].reshape((ywin, xwin))
        r = np.linalg.pinv(A)[2].rehsape((ywin, xwin))
        return (scipy.signal.fftconvolve(Z, -r, mode='valid'),
                scipy.signal.fftconvolve(Z, -c, mode='valid'))
    else:
        return None

def expand_2darray(z, n, mode, cval=None):
    """Expand a two-dimensional array with given edge modes.

    Args:
        z (:class:`numpy.ndarray`): Input 2-D array.
        n (int, tuple, or list): Number of pixels to expand.
        mode (string): Edge mode.
        cval (int or float): Constant value to fill the array.

    Returns:
        :class:`numpy.ndarray`: The expanded array.


    """
    if isinstance(z, int):
        nt, nb, nl, nr = n, n, n, n
    if isinstance(n, (tuple, list)):
        if len(n) == 2:
            nt, nb = n[0], n[0]
            nl, nr = n[1], n[1]
        elif len(n) == 4:
            nt, nb, nl, nr = n[0], n[1], n[2], n[3]
        else:
            raise ValueError

    new_shape = (z.shape[0] + nt + nb, z.shape[1] + nl + nr)
    Z = np.zeros(new_shape)

    Z[nt:-nb, nl:-nr] = z

    # pad input array with appropriate values at the four borders
    if mode == 'reflect':
        # top, bottom, left, and right bands
        Z[:nt, nl:-nr]  = np.flipud(z[:nt, :])
        Z[-nb:, nl:-nr] = np.flipud(z[-nb:, :])
        Z[nt:-nb, :nl]  = np.fliplr(z[:, :nl])
        Z[nt:-nb, -nr:] = np.fliplr(z[:, -nr:])

        # top-left, top-right, bottom-left, and bottom-right corners
        Z[:nt, :nl]   = np.flipud(np.fliplr(z[:nt, :nl]))
        Z[:nt, -nr:]  = np.flipud(np.fliplr(z[:nt, -nr:]))
        Z[-nb:, :nl]  = np.flipud(np.fliplr(z[-nb:, :nl]))
        Z[-nb:, -nr:] = np.flipud(np.fliplr(z[-nb:, -nr:]))

    elif mode == 'mirror':
        # top, bottom, left, and right bands
        Z[:nt, nl:-nr]  = np.flipud(z[1:1+nt, :])
        Z[-nb:, nl:-nr] = np.flipud(z[-nb-1:-1, :])
        Z[nt:-nb, :nl]  = np.fliplr(z[:, 1:1+nl])
        Z[nt:-nb, -nr:] = np.fliplr(z[:, -nr-1:-1])

        # top-left, top-right, bottom-left, and bottom-right corners
        Z[:nt, :nl]   = np.flipud(np.fliplr(z[1:1+nt, 1:1+nl]))
        Z[:nt, -nr:]  = np.flipud(np.fliplr(z[1:1+nt, -nr-1:-1]))
        Z[-nb:, :nl]  = np.flipud(np.fliplr(z[-nb-1:-1, 1:1+nl]))
        Z[-nb:, -nr:] = np.flipud(np.fliplr(z[-nb-1:-1, -nr-1:-1]))

    elif mode == 'nearest':
        # top, bottom, left, and right bands
        Z[:nt, nl:-nr]  = z[0, :]
        Z[-nb:, nl:-nr] = z[-1, :]
        Z[nt:-nb, :nl]  = z[:, 0].reshape(-1,1)
        Z[nt:-nb, -nr:] = z[:, -1].reshape(-1,1)

        # top-left, top-right, bottom-left, and bottom-right corners
        Z[:nt, :nl]   = z[0, 0]
        Z[:nt, -nr:]  = z[0, -1]
        Z[-nb:, :nl]  = z[-1, 0]
        Z[-nb:, -nr:] = z[-1, -1]

    elif mode == 'constant':
        if cval is None:
            raise ValueError
        # top, bottom, left, and right bands
        Z[:nt, nl:-nr]  = cval
        Z[-nb:, nl:-nr] = cval
        Z[nt:-nb, :nl]  = cval
        Z[nt:-nb, -nr:] = cval

        # top-left, top-right, bottom-left, and bottom-right corners
        Z[:nt, :nl]   = cval
        Z[:nt, -nr:]  = cval
        Z[-nb:, :nl]  = cval
        Z[-nb:, -nr:] = cval

    elif mode == 'z-symmetry':
        # top, bottom, left, and right bands
        Z[:nt, nl:-nr]  = z[0, :] - (np.flipud(z[1:1+nt, :]) - z[0, :])
        Z[-nb:, nl:-nr] = z[-1, :] - (np.flipud(z[-nb-1:-1, :]) - z[-1, :])
        band = np.tile(z[:,0].reshape(-1,1), [1,nl])
        Z[nt:-nb, :nl] = band - (np.fliplr(z[:, 1:1+nl]) - band)
        band = np.tile(z[:,-1].reshape(-1,1), [1,nr])
        Z[nt:-nb, -nr:] = band - (np.fliplr(z[:, -nr-1:-1]) - band)

        # top-left, top-right, bottom-left, and bottom-right corners
        Z[:nt,:nl]   = z[0,0] - (np.flipud(np.fliplr(z[1:1+nt,1:1+nl])) - z[0,0])
        Z[:nt,-nr:]  = z[0,-1] - (np.flipud(np.fliplr(z[1:1+nt,-nr-1:-1])) - z[0,-1])
        Z[-nb:,:nl]  = z[-1,0] - (np.flipud(np.fliplr(z[-nb-1:-1,1:1+nl])) - z[-1,0])
        Z[-nb:,-nr:] = z[-1,-1] - (np.flipud(np.fliplr(z[-nb-1:-1,-nr-1:-1])) - z[-1,-1])

    else:
        raise ValueError

    return Z
