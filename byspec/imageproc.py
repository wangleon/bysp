import multiprocessing as mp
import numpy as np


def _combine_clipdata(data, mask=None, mode='mean', upper_clip=None,
                      lower_clip=None, maxiter=10, maskmode=None):
    """Combine a clip data.

    Args:
        data (:class:`numpy.ndarray`): Datacube of input images.
        mask (:class:`numpy.ndarray`): Initial mask with the same shape with
            **data**.
        mode (str): Combine mode. Either "mean" or "sum".
        upper_clip (float): Upper threshold of the sigma-clipping. Default is
            *None*.
        lower_clip (float): Lower threshold of the sigma-clipping. Default is
            *None*.
        maxiter (int): Maximum number of iterations.
        maskmode (str): Mode of initial mask. Optional values are "min" and
            "max".
        nprocessors (int): Number of processors.

    Returns:
        :class:`numpy.ndarray`: Combined image array.

    See Also:
        :func:`combine_images`
    """

    nz, ny, nx = data.shape
    # generate a mask containing the positions of maximum pixel
    # along the first dimension

    if maskmode is None:
        mask2 = np.zeros_like(data, dtype=bool)
    elif maskmode == 'max':
        mask2 = (np.mgrid[0:nz, 0:ny, 0:nx][0] == data.argmax(axis=0))
    elif maskmode == 'min':
        mask2 = (np.mgrid[0:nz, 0:ny, 0:nx][0] == data.argmin(axis=0))
    else:
        print('Unknown maskmode:', maskmode)
        raise ValueError

    mask = np.logical_or(mask, mask2)

    # iteration begins
    for niter in range(maxiter):
        mdata = np.ma.masked_array(data, mask=mask)
        mean = mdata.mean(axis=0, dtype=np.float64).data
        std = mdata.std(axis=0, dtype=np.float64).data
        new_mask = np.ones_like(mask, dtype=bool)
        for i in np.arange(nz):
            chunk = data[i, :, :]

            # parse upper clipping
            if upper_clip is None:
                # mask1 = [False....]
                mask1 = np.zeros_like(chunk, dtype=bool)
            else:
                mask1 = chunk > mean + abs(upper_clip) * std

            # parse lower clipping
            if lower_clip is None:
                # mask2 = [False....]
                mask2 = np.zeros_like(chunk, dtype=bool)
            else:
                mask2 = chunk < mean - abs(lower_clip) * std

            new_mask[i, :, :] = np.logical_or(mask1, mask2)

        if new_mask.sum() == mask.sum():
            break
        mask = new_mask

    mdata = np.ma.masked_array(data, mask=mask)

    if mode == 'mean':
        return mdata.mean(axis=0).data
    elif mode == 'sum':
        return mdata.mean(axis=0).data * nz
    elif mode == 'median':
        return np.median(mdata, axis=0).data
    else:
        return None


def combine_images(data, mask=None, mode='mean', upper_clip=None,
                   lower_clip=None, maxiter=10, maskmode=None, ncores=1):
    """Combine multiple FITS images.

    Args:
        data (:class:`numpy.ndarray`): Datacube of input images.
        mask (:class:`numpy.ndarray`): Initial mask with the same shape with
            **data**.
        mode (str): Combine mode. Either "mean" or "sum".
        upper_clip (float): Upper threshold of the sigma-clipping. Default is
            *None*.
        lower_clip (float): Lower threshold of the sigma-clipping. Default is
            *None*.
        maxiter (int): Maximum number of iterations.
        maskmode (str): Mode of initial mask. Optional values are "min" and
            "max".
        ncores (int): Number of cores.

    Returns:
        :class:`numpy.ndarray`: Combined image array.

    Raises:
        TypeError: Dimension of **data** not equal to 3.
        ValueError: Unknown **mode** or **maskmode**.

    See Also:
        :func:`_combine_clipdata`

    This function can be used to calculate the median, mean, or sum of a list of
    FITS images.
    **maskmode** is the mode of initial mask. If "min" or "max" is given, the
    initial mask will be generated by blocking the minimum or maximum value of
    each pixel of the input images.
    If both **mask** and **maskmode** is given, the initial mask will be the
    logical *AND* of the input **mask** and the mask array generated by
    **maskmode**.

    """

    if data.ndim != 3:
        raise ValueError

    # if anyone of upper_clip and lower_clip is not None, then clip is True
    clip = (upper_clip is not None) or (lower_clip is not None)

    nimage, nY, nX = data.shape

    if clip:
        # perform sigma-clipping algorithm
        # initialize the final result array
        final_array = np.zeros((nY, nX))

        def get_fraction(N):
            if N > 8000:
                for i in [32, 16, 8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 4000:
                for i in [16, 8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 2000:
                for i in [8, 4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 1000:
                for i in [4, 2, 1]:
                    if N % i == 0: return N // i
            elif N > 500:
                for i in [2, 1]:
                    if N % i == 0: return N // i
            else:
                return N

        # split the image into small segmentations
        dy = get_fraction(nY)
        dx = get_fraction(nX)

        pool = mp.Pool(ncores)
        async_result_lst = {}

        if mask is None:
            mask = np.zeros_like(data, dtype=bool)

        # segmentation loop starts here
        for y1 in np.arange(0, nY, dy):
            y2 = y1 + dy
            for x1 in np.arange(0, nX, dx):
                x2 = x1 + dx

                clipdata = data[:, y1:y2, x1:x2]
                clipmask = mask[:, y1:y2, x1:x2]
                result = pool.apply_async(_combine_clipdata,
                                          args=(clipdata, clipmask, mode, upper_clip,
                                                lower_clip,
                                                maxiter, maskmode))
                async_result_lst[(x1, x2, y1, y2)] = result
        # segmentation loop ends here

        pool.close()
        pool.join()

        for key, result in async_result_lst.items():
            x1, x2, y1, y2 = key
            final_array[y1:y2, x1:x2] = result.get()

        return final_array
    else:
        if mode == 'mean':
            return data.mean(axis=0)
        elif mode == 'sum':
            return data.sum(axis=0)
        elif mode == 'median':
            return np.median(data, axis=0)
        else:
            raise ValueError
            return None
